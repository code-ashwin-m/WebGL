<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Red Square WebGL</title>
<style>
  body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; }
  canvas { width: 100%; height: 100%; display: block; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script>
// ---------------------------------------------------------
// Camera State
// ---------------------------------------------------------
let camX = 0, camY = 0;
let zoom = 1;

// --- Zoom limits ---
const MIN_ZOOM = 0.2;
const MAX_ZOOM = 5;
  
// Touch state
let lastX = 0, lastY = 0;
let lastDist = 0;
let lastMid = {x: 0, y: 0};
let isPinching = false;
let isTouching = false;

// Image state
let imgWidth = 1, imgHeight = 1;

let maskX = 250;
let maskY = 250;
let maskRx = 150;   // ellipse radius X
let maskRy = 100;   // ellipse radius Y
let maskRot = 0.0;  // radians
let maskIsSelected = false;
  
let isCenterDragging = false;
let centerTouchId = null;
let isResizing = false;
let isRotating = false;
let touchArea = 20;

const HANDLE_PX = 10;            // circle radius in screen pixels
const ROTATE_OFFSET_PX = 40;     // rotate handle offset above top
let activeHandle = null;
let rotateStartAngle = 0;
let rotateStartRot = 0;
  
function getEllipseHandlePositions() {
  const c = Math.cos(maskRot);
  const s = Math.sin(maskRot);
    
  function rot(x, y) {
    return {
      x: maskX + (x * c - y * s),
      y: maskY + (x * s + y * c)
    };
  }
    
  // Convert pixel offsets to world units
  const pixel = 1 / zoom;

  return {
      center: rot(0, 0),
      right:  rot(maskRx, 0),
      left:   rot(-maskRx, 0),
      top:    rot(0, maskRy),
      bottom: rot(0, -maskRy),
      rotate: rot(0, -(maskRy + ROTATE_OFFSET_PX * pixel))
  };
}

function isInsideCenterHandle(px, py) {
    const world = screenToWorld(px, py);
    const dx = world.x - maskX;
    const dy = world.y - maskY;
    return (dx*dx + dy*dy) <= (touchArea / zoom) * (touchArea / zoom);
}

function isInsideHandle(px, py, hx, hy) {
    const w = screenToWorld(px, py);
    const dx = w.x - hx;
    const dy = w.y - hy;
    const r = (HANDLE_PX+10) / zoom;  // convert px → world units
    return (dx*dx + dy*dy) <= (r*r);
}

function hitResizeOrRotate(px, py) {
    const h = getEllipseHandlePositions();

    if (isInsideHandle(px, py, h.center.x, h.center.y))
        return { type: "center" };

    if (isInsideHandle(px, py, h.right.x, h.right.y))
        return { type: "resize-right" };

    if (isInsideHandle(px, py, h.left.x, h.left.y))
        return { type: "resize-left" };

    if (isInsideHandle(px, py, h.top.x, h.top.y))
        return { type: "resize-top" };

    if (isInsideHandle(px, py, h.bottom.x, h.bottom.y))
        return { type: "resize-bottom" };

    if (isInsideHandle(px, py, h.rotate.x, h.rotate.y))
        return { type: "rotate" };

    return null;
}
  
function midpoint(t1, t2) {
  return {
    x: (t1.clientX + t2.clientX) / 2,
    y: (t1.clientY + t2.clientY) / 2
  };
}

function distance(t1, t2) {
  const dx = t2.clientX - t1.clientX;
  const dy = t2.clientY - t1.clientY;
  return Math.hypot(dx, dy);
}

// ---------------------------------------------------------
// Utility: convert screen (pixel) -> world coordinates
// ---------------------------------------------------------
function screenToWorld(px, py) {
  const w = canvas.width / zoom;
  const h = canvas.height / zoom;

  const left = camX;
  const bottom = camY;

  const x = left + (px / canvas.width) * w;
  const y = bottom + ((canvas.height - py) / canvas.height) * h;

  return { x, y };
}

// --------------------------
// Orthographic Projection
// --------------------------
function ortho(left, right, bottom, top, near, far) {
  return new Float32Array([
    2/(right-left), 0, 0, 0,
    0, 2/(top-bottom), 0, 0,
    0, 0, -2/(far-near), 0,
    -(right+left)/(right-left),
    -(top+bottom)/(top-bottom),
    -(far+near)/(far-near),
    1
  ]);
}
  
// -------------------- SHADERS --------------------
const vsSource = `
attribute vec2 a_Pos;
attribute vec2 a_Tex;
uniform mat4 u_proj;
varying vec2 v_Tex;

void main() {
    gl_Position = u_proj * vec4(a_Pos, 0.0, 1.0);
    v_Tex = a_Tex;
}
`;

const fsSource = `
precision mediump float;
varying vec2 v_Tex;
uniform sampler2D u_Tex;
void main() {
    gl_FragColor = texture2D(u_Tex, v_Tex);
}
`;

const vsMaskSource = `
attribute vec2 a_Pos;
uniform mat4 u_proj;
varying vec2 v_worldPos;
void main() {
    v_worldPos = a_Pos;
    gl_Position = u_proj * vec4(a_Pos, 0.0, 1.0);
}
`;

const fsMaskSource = `
precision mediump float;

uniform vec2 uCenter;     // world pos
uniform float uRx;        // ellipse radius X (world)
uniform float uRy;        // ellipse radius Y (world)
uniform float uRotation;  // radians
uniform float uThicknessPx; // world thickness
uniform float uFeatherPx;   // softness

uniform float uOutlinePx; // 1px black outline width in SCREEN pixels
uniform float uPixelSize; // world units per screen pixel (1/zoom)

varying vec2 v_worldPos;

float ellipseDist(vec2 p, vec2 center, float rx, float ry, float rotation) {
    // translate
    vec2 d = p - center;

    // rotate by -rotation
    float c = cos(rotation);
    float s = sin(rotation);
    vec2 r = vec2(
        d.x * c + d.y * s,
       -d.x * s + d.y * c
    );

    // normalized ellipse distance
    return length(vec2(r.x / rx, r.y / ry));
}

void main() {
    float d = ellipseDist(v_worldPos, uCenter, uRx, uRy, uRotation);
    
    // Convert world thickness to normalized ellipse distance:
    float normThickness = uThicknessPx / min(uRx, uRy);
    float normFeather   = uFeatherPx   / min(uRx, uRy);

    // ---- Main white ring ----
    float inner = 1.0 - normThickness;
    float outer = 1.0 + normThickness;
    
    float whiteRing =
        smoothstep(inner - normFeather, inner + normFeather, d) *
        (1.0 - smoothstep(outer - normFeather, outer + normFeather, d));
    
    // ---- Outer 1px black outline ----
    float outlineInner = outer;
    float outlineOuter = outer + (uOutlinePx * uPixelSize) / min(uRx, uRy);

    float blackRing =
        smoothstep(outlineInner - normFeather, outlineInner + normFeather, d) *
        (1.0 - smoothstep(outlineOuter - normFeather, outlineOuter + normFeather, d));

    // Composite: black ring behind white ring
    float finalAlpha = max(whiteRing, blackRing);

    if (finalAlpha < 0.01) discard;

    vec3 color =
        (blackRing > whiteRing) ?
        vec3(0.0) :          // black outer border
        vec3(1.0);           // white inner ring

    gl_FragColor = vec4(color, finalAlpha);
}
`;

// -------------------- INIT WEBGL --------------------
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");
if (!gl) alert("WebGL not supported");

function compileShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        alert(gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
}

const vs = compileShader(gl.VERTEX_SHADER, vsSource);
const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);

const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);
  
const vsMask = compileShader(gl.VERTEX_SHADER, vsMaskSource);
const fsMask = compileShader(gl.FRAGMENT_SHADER, fsMaskSource);

const maskProgram = gl.createProgram();
gl.attachShader(maskProgram, vsMask);
gl.attachShader(maskProgram, fsMask);
gl.linkProgram(maskProgram);

const aPos = gl.getAttribLocation(program, "a_Pos");
const aTex = gl.getAttribLocation(program, "a_Tex");
const uTex = gl.getUniformLocation(program, "u_Tex");
const uProj = gl.getUniformLocation(program, "u_proj");

const aMaskPos = gl.getAttribLocation(maskProgram, "a_Pos");
const uMaskProj = gl.getUniformLocation(maskProgram, "u_proj");
const uMaskCenter = gl.getUniformLocation(maskProgram, "uCenter");
const uMaskThicknessPx = gl.getUniformLocation(maskProgram, "uThicknessPx");  
const uMaskFeatherPx = gl.getUniformLocation(maskProgram, "uFeatherPx");
const uMaskOutlinePx = gl.getUniformLocation(maskProgram, "uOutlinePx");
const uMaskPixelSize = gl.getUniformLocation(maskProgram, "uPixelSize");
const uMaskRx = gl.getUniformLocation(maskProgram, "uRx");
const uMaskRy = gl.getUniformLocation(maskProgram, "uRy");
const uMaskRotation = gl.getUniformLocation(maskProgram, "uRotation");
  
function createScreenBuffer(){
  //gl.viewport(0, 0, canvas.width, canvas.height);
  
  const screenVertices = new Float32Array([
    //X,   Y
    0,   imgHeight,  // bottom-left
    imgWidth, imgHeight,  // bottom-right
    imgWidth, 0,              // top-right
    0,   0,              // top-left
  ]);
  
  const screenIndices = new Uint16Array([
    3, 2, 0,
    0, 1, 2
  ]);
  
  // ---- VBO ----
  const screenBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, screenBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, screenVertices, gl.STATIC_DRAW);
  
  // ---- EBO (Index Buffer) ----
  const screenIBO = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenIBO);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, screenIndices, gl.STATIC_DRAW);

  gl.enableVertexAttribArray(aMaskPos);
  gl.vertexAttribPointer(aMaskPos, 2, gl.FLOAT, false, 16, 0);

}

function createImageBuffer(){
  // -------------------- RECTANGLE GEOMETRY --------------------
  // Full-screen rectangle (-1 to +1)
  const vertices = new Float32Array([
    //  X,   Y,   U,  V
    0,        imgHeight,  0,  0,  // bottom-left
    imgWidth, imgHeight,  1,  0,  // bottom-right
    imgWidth, 0,          1,  1,  // top-right
    0,        0,          0,  1   // top-left
  ]);
  
  const indices = new Uint16Array([
    3, 2, 0,
    0, 1, 2
  ]);
  
  // ---- VBO ----
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

  // ---- EBO (Index Buffer) ----
  const ibo = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 16, 0);

  gl.enableVertexAttribArray(aTex);
  gl.vertexAttribPointer(aTex, 2, gl.FLOAT, false, 16, 8);

  gl.uniform1i(uTex, 0); // bind texture unit 0
}

function loadImageToTexture(image){
    const tex = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,image);

    const err = gl.getError();
    console.log("GL ERROR after texImage2D:", err);
  
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
}
// -------------------- LOAD IMAGE --------------------
const image = new Image();
image.src = "http://192.168.1.35:8080/img1.jpg";  // ← your image
image.onload = () => {
    console.log("IMAGE LOADED");
    imgHeight = image.height;
    imgWidth = image.width;
    
    createScreenBuffer();
    createImageBuffer();
    loadImageToTexture(image);
};

function resetViewToFit() {
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
  
  const screenW = canvas.clientWidth;
  const screenH = canvas.clientHeight;

  // Fit image inside screen
  zoom = Math.min(screenW / imgWidth, screenH / imgHeight);

  // Compute how large the ortho window will become
  const viewW = screenW / zoom;
  const viewH = screenH / zoom;

  // Center camera so image is perfectly centered
  camX = (imgWidth  - viewW) / 2;
  camY = (imgHeight - viewH) / 2;
}

function renderMaskSelection(centerX, centerY){
  gl.useProgram(maskProgram);
  
  gl.uniform2f(uMaskCenter, centerX, centerY);
  gl.uniform1f(uMaskRx, maskRx);
  gl.uniform1f(uMaskRy, maskRy);
  gl.uniform1f(uMaskRotation, maskRot);
  gl.uniform1f(uMaskThicknessPx, 1.0/zoom);
  gl.uniform1f(uMaskFeatherPx, 0.2); // Try 1→3 for smoother edges
  // black outline stays exactly 1px on screen
  gl.uniform1f(uMaskOutlinePx, 1.0);
  // world units per pixel
  gl.uniform1f(uMaskPixelSize, 1.0 / zoom);
  
  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
}
  
function renderHandleCircle(x, y) {
    gl.useProgram(maskProgram);
    gl.uniform2f(uMaskCenter, x, y);

    const rad = (HANDLE_PX * 0.5) / zoom;
    const thick = (HANDLE_PX * 0.6) / zoom;

    gl.uniform1f(uMaskRx, rad);
    gl.uniform1f(uMaskRy, rad);
    gl.uniform1f(uMaskThicknessPx, thick);
    gl.uniform1f(uMaskFeatherPx, 0.7 / zoom);
    gl.uniform1f(uMaskOutlinePx, 1.0);
    gl.uniform1f(uMaskPixelSize, 1.0 / zoom);

    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
}

function renderMaskCenterHandles() {
  let w = canvas.width / zoom;
  let h = canvas.height / zoom;

  let left = camX;
  let right = camX + w;
  let bottom = camY;
  let top = camY + h;
  
  gl.useProgram(maskProgram);
  const maskProj = ortho(left, right, bottom, top, -1, 1);
  gl.uniformMatrix4fv(uMaskProj, false, maskProj);
  
  // A small circle (white)
  gl.uniform2f(uMaskCenter, maskX, maskY);

  // Screen-pixel-constant radius
  const handleRadiusPx = 12; // 12px diameter
  const rad = HANDLE_PX / zoom;
  const thick = (HANDLE_PX * 0.6) / zoom;
  
  gl.uniform1f(uMaskRx, rad);
  gl.uniform1f(uMaskRy, rad);
  gl.uniform1f(uMaskThicknessPx, thick);
  gl.uniform1f(uMaskFeatherPx, 0.7);
  gl.uniform1f(uMaskOutlinePx, 1.0);
  gl.uniform1f(uMaskPixelSize, 1.0 / zoom);

  // Draw on same quad
  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

  if (maskIsSelected){
    renderMaskSelection(maskX, maskY);

    const handle = getEllipseHandlePositions();
    // resize handles
    renderHandleCircle(handle.right.x, handle.right.y);
    renderHandleCircle(handle.left.x, handle.left.y);
    renderHandleCircle(handle.top.x, handle.top.y);
    renderHandleCircle(handle.bottom.x, handle.bottom.y);

    // rotate handle
    renderHandleCircle(handle.rotate.x, handle.rotate.y);
  }
}
  
// -------------------- DRAW --------------------
function draw() {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
    
    let w = canvas.width / zoom;
    let h = canvas.height / zoom;

    let left = camX;
    let right = camX + w;
    let bottom = camY;
    let top = camY + h;
    
    gl.useProgram(program);
    const proj = ortho(left, right, bottom, top, -1, 1);
    gl.uniformMatrix4fv(uProj, false, proj);
  
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
  
    //Render Image
    gl.disable(gl.GL_BLEND);
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    renderMaskCenterHandles();
}

// ---------------------------------------------------------
// Touch Events (Pan + Pinch Zoom)
// ---------------------------------------------------------
canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  
  const t = e.touches[0];
  const hit = hitResizeOrRotate(t.clientX, t.clientY);
  if (hit) {
      activeHandle = hit.type;
      centerTouchId = t.identifier;
      lastX = t.clientX;
      lastY = t.clientY;
      
      if (hit.type === "rotate") {
        const h = getEllipseHandlePositions().rotate;
        const worldStart = screenToWorld(t.clientX, t.clientY);
        // save initial angle between center and touch
        rotateStartAngle = Math.atan2(worldStart.y - maskY, worldStart.x - maskX);
        // save current ellipse rotation
        rotateStartRot = maskRot;
      }
      return;
  }

  if (e.touches.length === 1) {
    // Single-finger pan
    isTouching = true;
    isPinching = false;
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  } else if (e.touches.length === 2) {
    // Start pinch
    isPinching = true;
    lastDist = distance(e.touches[0], e.touches[1]);
    lastMid = midpoint(e.touches[0], e.touches[1]);
  }
});

function worldDeltaToLocal(dx, dy) {
    const c = Math.cos(-maskRot);
    const s = Math.sin(-maskRot);
    return {
        x: dx * c - dy * s,
        y: dx * s + dy * c
    };
}
  
canvas.addEventListener("touchmove", e => {
  e.preventDefault();

  if (activeHandle) {
    const t = [...e.touches].find(x => x.identifier === centerTouchId);
    if (!t) return;

    const before = screenToWorld(lastX, lastY);
    const now    = screenToWorld(t.clientX, t.clientY);

    const dx = now.x - before.x;
    const dy = now.y - before.y;

    let loc = null;
    switch(activeHandle) {

        case "center":
            isCenterDragging = true;
            maskX += dx;
            maskY += dy;
            break;

        case "resize-right":
           loc = worldDeltaToLocal(dx, dy);
           maskRx += loc.x;     // only x-direction in local space affects rx
           if (maskRx < 5) maskRx = 5;
           break;

        case "resize-left":
           loc = worldDeltaToLocal(dx, dy);
           maskRx -= loc.x;     // inverted
           if (maskRx < 5) maskRx = 5;
           break;

        case "resize-top":
           loc = worldDeltaToLocal(dx, dy);
           maskRy += loc.y;
           if (maskRy < 5) maskRy = 5;
           break;

        case "resize-bottom":
           loc = worldDeltaToLocal(dx, dy);
           maskRy -= loc.y;
           if (maskRy < 5) maskRy = 5;
           break;

        case "rotate":
            //const h = getEllipseHandlePositions();
            //const ang = Math.atan2(now.y - maskY, now.x - maskX);
           // maskRot = ( ang - Math.PI/2 );
            //break;
          const worldNow = screenToWorld(t.clientX, t.clientY);
          const nowAngle = Math.atan2(worldNow.y - maskY, worldNow.x - maskX);
          // delta between angles
          const delta = nowAngle - rotateStartAngle;
          // update rotation
          maskRot = rotateStartRot + delta;
          break;
    }

    lastX = t.clientX;
    lastY = t.clientY;
    draw();
    return;
  }

  // --- Pinch Zoom ---
  if (isPinching && e.touches.length === 2) {
    const t1 = e.touches[0];
    const t2 = e.touches[1];

    // Midpoint in client coords
    const mid = midpoint(t1, t2);

    // Convert midpoint to world coords BEFORE zooming
    const worldBefore = screenToWorld(mid.x, mid.y);

    // Zoom amount
    let newDist = distance(t1, t2);
    let scale = newDist / lastDist;

    // Apply zoom with limits
    let newZoom = zoom * scale;
    newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));

    // Adjust pan so world point under fingers stays stable
    zoom = newZoom;

    // Convert midpoint to world coords AFTER zooming
    const worldAfter = screenToWorld(mid.x, mid.y);

    // Offset camera to keep focus stable
    camX += (worldBefore.x - worldAfter.x);
    camY += (worldBefore.y - worldAfter.y);

    lastDist = newDist;
    lastMid = mid;

    draw();
    return;
  }
  
  // ----- Single finger pan -----
  if (isTouching && e.touches.length === 1) {
    const t = e.touches[0];

    let dx = t.clientX - lastX;
    let dy = t.clientY - lastY;

    camX -= dx * (1 / zoom);
    camY += dy * (1 / zoom);

    lastX = t.clientX;
    lastY = t.clientY;

    draw();
  }
});
  
canvas.addEventListener("touchend", e => {
  if (activeHandle == "center" && !isCenterDragging){
    maskIsSelected = !maskIsSelected;
    draw();
  }
  
  isCenterDragging = false;
  isResizing = false;
  isRotating = false;
  centerTouchId = null;
  activeHandle = null;

  if (e.touches.length < 2) {
    isTouching = false;
    isPinching = false;
  }
});
  
// ---------------------------------------------------------
// Mouse support (optional)
// ---------------------------------------------------------
let mouseDown = false;
  
canvas.addEventListener("mousedown", e => {
  mouseDown = true;
  lastX = e.clientX;
  lastY = e.clientY;
});
canvas.addEventListener("mouseup", () => mouseDown = false);
canvas.addEventListener("mousemove", e => {
  if (!mouseDown) return;
  let dx = e.clientX - lastX;
  let dy = e.clientY - lastY;

  camX -= dx * (1 / zoom);
  camY += dy * (1 / zoom);

  lastX = e.clientX;
  lastY = e.clientY;

  draw();
});
canvas.addEventListener("wheel", e => {
  const z = 1.1;
  zoom *= (e.deltaY < 0 ? z : 1/z);
  zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));
  draw();
});

  
function init() {
    resetViewToFit();
    draw();           // ✓ draw first frame
}
  
window.onload = init;
</script>
</body>
</html>