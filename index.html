<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Red Square WebGL</title>
<style>
  body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; }
  canvas { width: 100%; height: 100%; display: block; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script>
// ---------------------------------------------------------
// Camera State
// ---------------------------------------------------------
let camX = 0, camY = 0;
let zoom = 1;

// --- Zoom limits ---
const MIN_ZOOM = 0.2;
const MAX_ZOOM = 5;
  
// Touch state
let lastX = 0, lastY = 0;
let lastDist = 0;
let lastMid = {x: 0, y: 0};
let isPinching = false;
let isTouching = false;

// Image state
let imgWidth = 1, imgHeight = 1;

let maskX = 250;
let maskY = 250;
let maskRadius = 100;

let isCenterDragging = false;
let centerTouchId = null;

function isInsideCenterHandle(px, py) {
    const world = screenToWorld(px, py);
    const dx = world.x - maskX;
    const dy = world.y - maskY;
    return (dx*dx + dy*dy) <= (20 / zoom) * (20 / zoom);
}
  
function midpoint(t1, t2) {
  return {
    x: (t1.clientX + t2.clientX) / 2,
    y: (t1.clientY + t2.clientY) / 2
  };
}

function distance(t1, t2) {
  const dx = t2.clientX - t1.clientX;
  const dy = t2.clientY - t1.clientY;
  return Math.hypot(dx, dy);
}

// ---------------------------------------------------------
// Utility: convert screen (pixel) -> world coordinates
// ---------------------------------------------------------
function screenToWorld(px, py) {
  const w = canvas.width / zoom;
  const h = canvas.height / zoom;

  const left = camX;
  const bottom = camY;

  const x = left + (px / canvas.width) * w;
  const y = bottom + ((canvas.height - py) / canvas.height) * h;

  return { x, y };
}

// --------------------------
// Orthographic Projection
// --------------------------
function ortho(left, right, bottom, top, near, far) {
  return new Float32Array([
    2/(right-left), 0, 0, 0,
    0, 2/(top-bottom), 0, 0,
    0, 0, -2/(far-near), 0,
    -(right+left)/(right-left),
    -(top+bottom)/(top-bottom),
    -(far+near)/(far-near),
    1
  ]);
}
  
// -------------------- SHADERS --------------------
const vsSource = `
attribute vec2 a_Pos;
attribute vec2 a_Tex;
uniform mat4 u_proj;
varying vec2 v_Tex;

void main() {
    gl_Position = u_proj * vec4(a_Pos, 0.0, 1.0);
    v_Tex = a_Tex;
}
`;

const fsSource = `
precision mediump float;
varying vec2 v_Tex;
uniform sampler2D u_Tex;
void main() {
    gl_FragColor = texture2D(u_Tex, v_Tex);
}
`;

const vsMaskSource = `
attribute vec2 a_Pos;
uniform mat4 u_proj;
varying vec2 v_worldPos;
void main() {
    v_worldPos = a_Pos;
    gl_Position = u_proj * vec4(a_Pos, 0.0, 1.0);
}
`;

const fsMaskSource = `
precision mediump float;

uniform vec2 uCenter;     // world pos
uniform float uRadius;    // world radius
uniform float uThickness; // world thickness
uniform float uFeather;   // softness

uniform float uOutlinePx; // 1px black outline width in SCREEN pixels
uniform float uPixelSize; // world units per screen pixel (1/zoom)

varying vec2 v_worldPos;

void main() {
    float d = distance(v_worldPos, uCenter);

    // ---- Main white ring ----
    float inner = uRadius - uThickness;
    float outer = uRadius + uThickness;

    float whiteRing =
        smoothstep(inner - uFeather, inner + uFeather, d) *
        (1.0 - smoothstep(outer - uFeather, outer + uFeather, d));

    // ---- Outer 1px black outline ----
    float outlineOuter = uRadius + uThickness + uOutlinePx * uPixelSize;
    float outlineInner = uRadius + uThickness;

    float blackRing =
        smoothstep(outlineInner - uFeather, outlineInner + uFeather, d) *
        (1.0 - smoothstep(outlineOuter - uFeather, outlineOuter + uFeather, d));

    // Composite: black ring behind white ring
    float finalAlpha = max(whiteRing, blackRing);

    if (finalAlpha < 0.01) discard;

    vec3 color =
        (blackRing > whiteRing) ?
        vec3(0.0) :          // black outer border
        vec3(1.0);           // white inner ring

    gl_FragColor = vec4(color, finalAlpha);
}
`;

// -------------------- INIT WEBGL --------------------
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");
if (!gl) alert("WebGL not supported");

function compileShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
}

const vs = compileShader(gl.VERTEX_SHADER, vsSource);
const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);

const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);
  
const vsMask = compileShader(gl.VERTEX_SHADER, vsMaskSource);
const fsMask = compileShader(gl.FRAGMENT_SHADER, fsMaskSource);

const maskProgram = gl.createProgram();
gl.attachShader(maskProgram, vsMask);
gl.attachShader(maskProgram, fsMask);
gl.linkProgram(maskProgram);

const aPos = gl.getAttribLocation(program, "a_Pos");
const aTex = gl.getAttribLocation(program, "a_Tex");
const uTex = gl.getUniformLocation(program, "u_Tex");
const uProj = gl.getUniformLocation(program, "u_proj");

const aMaskPos = gl.getAttribLocation(maskProgram, "a_Pos");
const uMaskProj = gl.getUniformLocation(maskProgram, "u_proj");
const uMaskCenter = gl.getUniformLocation(maskProgram, "uCenter");
const uMaskRadius = gl.getUniformLocation(maskProgram, "uRadius");
const uMaskThickness = gl.getUniformLocation(maskProgram, "uThickness");  
const uMaskFeather = gl.getUniformLocation(maskProgram, "uFeather");
const uMaskOutlinePx = gl.getUniformLocation(maskProgram, "uOutlinePx");
const uMaskPixelSize = gl.getUniformLocation(maskProgram, "uPixelSize");
  
function createScreenBuffer(){
  //gl.viewport(0, 0, canvas.width, canvas.height);
  
  const screenVertices = new Float32Array([
    //X,   Y
    0,   imgHeight,  // bottom-left
    imgWidth, imgHeight,  // bottom-right
    imgWidth, 0,              // top-right
    0,   0,              // top-left
  ]);
  
  const screenIndices = new Uint16Array([
    3, 2, 0,
    0, 1, 2
  ]);
  
  // ---- VBO ----
  const screenBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, screenBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, screenVertices, gl.STATIC_DRAW);
  
  // ---- EBO (Index Buffer) ----
  const screenIBO = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenIBO);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, screenIndices, gl.STATIC_DRAW);

  gl.enableVertexAttribArray(aMaskPos);
  gl.vertexAttribPointer(aMaskPos, 2, gl.FLOAT, false, 16, 0);

}

function createImageBuffer(){
  // -------------------- RECTANGLE GEOMETRY --------------------
  // Full-screen rectangle (-1 to +1)
  const vertices = new Float32Array([
    //  X,   Y,   U,  V
    0,        imgHeight,  0,  0,  // bottom-left
    imgWidth, imgHeight,  1,  0,  // bottom-right
    imgWidth, 0,          1,  1,  // top-right
    0,        0,          0,  1   // top-left
  ]);
  
  const indices = new Uint16Array([
    3, 2, 0,
    0, 1, 2
  ]);
  
  // ---- VBO ----
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

  // ---- EBO (Index Buffer) ----
  const ibo = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 16, 0);

  gl.enableVertexAttribArray(aTex);
  gl.vertexAttribPointer(aTex, 2, gl.FLOAT, false, 16, 8);

  gl.uniform1i(uTex, 0); // bind texture unit 0
}

function loadImageToTexture(image){
    const tex = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,image);

    const err = gl.getError();
    console.log("GL ERROR after texImage2D:", err);
  
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
}
// -------------------- LOAD IMAGE --------------------
const image = new Image();
image.src = "http://192.168.1.35:8080/img1.jpg";  // ← your image
image.onload = () => {
    console.log("IMAGE LOADED");
    imgHeight = image.height;
    imgWidth = image.width;
    
    createScreenBuffer();
    createImageBuffer();
    loadImageToTexture(image);
};

function resetViewToFit() {
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
  
  const screenW = canvas.clientWidth;
  const screenH = canvas.clientHeight;

  // Fit image inside screen
  zoom = Math.min(screenW / imgWidth, screenH / imgHeight);

  // Compute how large the ortho window will become
  const viewW = screenW / zoom;
  const viewH = screenH / zoom;

  // Center camera so image is perfectly centered
  camX = (imgWidth  - viewW) / 2;
  camY = (imgHeight - viewH) / 2;
}

function renderMaskSelection(centerX, centerY){
  gl.useProgram(maskProgram);
  
  gl.uniform2f(uMaskCenter, centerX, centerY);
  gl.uniform1f(uMaskRadius, 100.0);
  gl.uniform1f(uMaskThickness, 1.0/zoom);
  gl.uniform1f(uMaskFeather, 0.2); // Try 1→3 for smoother edges
  // black outline stays exactly 1px on screen
  gl.uniform1f(uMaskOutlinePx, 1.0);
  // world units per pixel
  gl.uniform1f(uMaskPixelSize, 1.0 / zoom);
  
  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
}

function renderMaskCenterHandles() {
  let w = canvas.width / zoom;
  let h = canvas.height / zoom;

  let left = camX;
  let right = camX + w;
  let bottom = camY;
  let top = camY + h;
  
  gl.useProgram(maskProgram);
  const maskProj = ortho(left, right, bottom, top, -1, 1);
  gl.uniformMatrix4fv(uMaskProj, false, maskProj);
  
  // A small circle (white)
  gl.uniform2f(uMaskCenter, maskX, maskY);

  // Screen-pixel-constant radius
  const handleRadiusPx = 12; // 12px diameter
  const handleThicknessPx = 6;

  gl.uniform1f(uMaskRadius, (handleRadiusPx / zoom));
  gl.uniform1f(uMaskThickness, (handleThicknessPx / zoom));
  gl.uniform1f(uMaskFeather, 0.7 / zoom);

  gl.uniform1f(uMaskOutlinePx, 1.0);
  gl.uniform1f(uMaskPixelSize, 1.0 / zoom);

  // Draw on same quad
  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
  
  renderMaskSelection(maskX, maskY);
}
  
// -------------------- DRAW --------------------
function draw() {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
    
    let w = canvas.width / zoom;
    let h = canvas.height / zoom;

    let left = camX;
    let right = camX + w;
    let bottom = camY;
    let top = camY + h;
    
    gl.useProgram(program);
    const proj = ortho(left, right, bottom, top, -1, 1);
    gl.uniformMatrix4fv(uProj, false, proj);
  
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
  
    //Render Image
    gl.disable(gl.GL_BLEND);
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    renderMaskCenterHandles();
}

// ---------------------------------------------------------
// Touch Events (Pan + Pinch Zoom)
// ---------------------------------------------------------
canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  
  const t = e.touches[0];
  if (isInsideCenterHandle(t.clientX, t.clientY)) {
    //alert("selected");
    isCenterDragging = true;
    centerTouchId = t.identifier;
    lastX = t.clientX;
    lastY = t.clientY;
    return;
  }

  if (e.touches.length === 1) {
    // Single-finger pan
    isTouching = true;
    isPinching = false;
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  } else if (e.touches.length === 2) {
    // Start pinch
    isPinching = true;
    lastDist = distance(e.touches[0], e.touches[1]);
    lastMid = midpoint(e.touches[0], e.touches[1]);
  }
});

canvas.addEventListener("touchmove", e => {
  e.preventDefault();

  // --- move mask center ---
  if (isCenterDragging) {
      const t = [...e.touches].find(t => t.identifier === centerTouchId);
      if (t) {
          const dx = t.clientX - lastX;
          const dy = t.clientY - lastY;

          maskX += dx / zoom;
          maskY -= dy / zoom;

          lastX = t.clientX;
          lastY = t.clientY;
          draw();
      }
      return;
  }

  // --- Pinch Zoom ---
  if (isPinching && e.touches.length === 2) {
    const t1 = e.touches[0];
    const t2 = e.touches[1];

    // Midpoint in client coords
    const mid = midpoint(t1, t2);

    // Convert midpoint to world coords BEFORE zooming
    const worldBefore = screenToWorld(mid.x, mid.y);

    // Zoom amount
    let newDist = distance(t1, t2);
    let scale = newDist / lastDist;

    // Apply zoom with limits
    let newZoom = zoom * scale;
    newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));

    // Adjust pan so world point under fingers stays stable
    zoom = newZoom;

    // Convert midpoint to world coords AFTER zooming
    const worldAfter = screenToWorld(mid.x, mid.y);

    // Offset camera to keep focus stable
    camX += (worldBefore.x - worldAfter.x);
    camY += (worldBefore.y - worldAfter.y);

    lastDist = newDist;
    lastMid = mid;

    draw();
    return;
  }
  
  // ----- Single finger pan -----
  if (isTouching && e.touches.length === 1) {
    const t = e.touches[0];

    let dx = t.clientX - lastX;
    let dy = t.clientY - lastY;

    camX -= dx * (1 / zoom);
    camY += dy * (1 / zoom);

    lastX = t.clientX;
    lastY = t.clientY;

    draw();
  }
});
  
canvas.addEventListener("touchend", e => {
  if (isCenterDragging) {
      isCenterDragging = false;
      centerTouchId = null;
  }

  if (e.touches.length < 2) {
    isTouching = false;
    isPinching = false;
  }
});
  
// ---------------------------------------------------------
// Mouse support (optional)
// ---------------------------------------------------------
let mouseDown = false;
  
canvas.addEventListener("mousedown", e => {
  mouseDown = true;
  lastX = e.clientX;
  lastY = e.clientY;
});
canvas.addEventListener("mouseup", () => mouseDown = false);
canvas.addEventListener("mousemove", e => {
  if (!mouseDown) return;
  let dx = e.clientX - lastX;
  let dy = e.clientY - lastY;

  camX -= dx * (1 / zoom);
  camY += dy * (1 / zoom);

  lastX = e.clientX;
  lastY = e.clientY;

  draw();
});
canvas.addEventListener("wheel", e => {
  const z = 1.1;
  zoom *= (e.deltaY < 0 ? z : 1/z);
  zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));
  draw();
});

  
function init() {
    resetViewToFit();
    draw();           // ✓ draw first frame
}
  
window.onload = init;
</script>
</body>
</html>