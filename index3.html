<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Red Square WebGL</title>
<style>
  body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; }
  canvas { width: 100%; height: 100%; display: block; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script>
// ---------------------------------------------------------
// Camera State
// ---------------------------------------------------------
let camX = 0, camY = 0;
let zoom = 1;

// --- Zoom limits ---
const MIN_ZOOM = 0.2;
const MAX_ZOOM = 5;
  
// Touch state
let lastX = 0, lastY = 0;
let lastDist = 0;
let lastMid = {x: 0, y: 0};
let isPinching = false;
let isTouching = false;

// Image state
let imgWidth = 1, imgHeight = 1;

let maskCurrent = null;
  
let isCenterDragging = false;
let centerTouchId = null;
let isResizing = false;
let isRotating = false;
let touchArea = 20;

const HANDLE_PX = 10;            // circle radius in screen pixels
const ROTATE_OFFSET_PX = 40;     // rotate handle offset above top
let activeHandle = null;
let rotateStartAngle = 0;
let rotateStartRot = 0;

class Mask {
    constructor(id, type = "circle") {
        this.id = id;              // Unique identifier
        this.type = type;          // "circle" or "ellipse"
        this.center = { x: 250, y: 250 };
        this.rx = 150; this.ry = 100; // For ellipse
        this.rotation = 0;         // Rotation in radians (for ellipse)
        this.selected = false;     // If this mask is active/selected
        this.outline = false;

        // NEW: per-mask feather (in screen pixels) and exposure (in stops)
        this.feather = 30;         // default feather radius in screen px
        this.exposure = 0.0;       // exposure in stops (Lightroom style)
    }
}

let masks = [];
let nextMaskId = 1; // To assign unique IDs

function addMask(type = "circle") {
    const mask = new Mask(nextMaskId++, type);
    masks.push(mask);
    return mask;
}

function removeMask(id) {
    masks = masks.filter(mask => mask.id !== id);
}

function selectMask(id) {
    masks.forEach(mask => mask.selected = (mask.id === id));
}

addMask();
addMask();
addMask();
  
function getEllipseHandlePositions(mask) {
  const c = Math.cos(mask.rotation);
  const s = Math.sin(mask.rotation);
    
  function rot(x, y) {
    return {
      x: mask.center.x + (x * c - y * s),
      y: mask.center.y + (x * s + y * c)
    };
  }
    
  // Convert pixel offsets to world units
  const pixel = 1 / zoom;

  return {
      center: rot(0, 0),
      right:  rot(mask.rx, 0),
      left:   rot(-mask.rx, 0),
      top:    rot(0, mask.ry),
      bottom: rot(0, -mask.ry),
      rotate: rot(0, -(mask.ry + ROTATE_OFFSET_PX * pixel))
  };
}

function isInsideCenterHandle(px, py) {
    const world = screenToWorld(px, py);
    const dx = world.x - maskX;
    const dy = world.y - maskY;
    return (dx*dx + dy*dy) <= (touchArea / zoom) * (touchArea / zoom);
}

function isInsideHandle(px, py, hx, hy) {
    const w = screenToWorld(px, py);
    const dx = w.x - hx;
    const dy = w.y - hy;
    const r = (HANDLE_PX + 20) / zoom;  // convert px → world units
    return (dx*dx + dy*dy) <= (r*r);
}

function hitResizeOrRotate(px, py) {
  for (let mask of masks) {
    const h = getEllipseHandlePositions(mask);

    if (isInsideHandle(px, py, h.center.x, h.center.y))
        return { type: "center", mask: mask };

    if (isInsideHandle(px, py, h.right.x, h.right.y) && mask.outline)
        return { type: "resize-right", mask: mask };

    if (isInsideHandle(px, py, h.left.x, h.left.y) && mask.outline)
        return { type: "resize-left", mask: mask };

    if (isInsideHandle(px, py, h.top.x, h.top.y) && mask.outline)
        return { type: "resize-top", mask: mask };

    if (isInsideHandle(px, py, h.bottom.x, h.bottom.y) && mask.outline)
        return { type: "resize-bottom", mask: mask };

    if (isInsideHandle(px, py, h.rotate.x, h.rotate.y) && mask.outline)
        return { type: "rotate", mask: mask };
  };
  return null;
}
  
function midpoint(t1, t2) {
  return {
    x: (t1.clientX + t2.clientX) / 2,
    y: (t1.clientY + t2.clientY) / 2
  };
}

function distance(t1, t2) {
  const dx = t2.clientX - t1.clientX;
  const dy = t2.clientY - t1.clientY;
  return Math.hypot(dx, dy);
}

// ---------------------------------------------------------
// Utility: convert screen (pixel) -> world coordinates
// ---------------------------------------------------------
function screenToWorld(px, py) {
  const w = canvas.width / zoom;
  const h = canvas.height / zoom;

  const left = camX;
  const bottom = camY;

  const x = left + (px / canvas.width) * w;
  const y = bottom + ((canvas.height - py) / canvas.height) * h;

  return { x, y };
}

// --------------------------
// Orthographic Projection
// --------------------------
function ortho(left, right, bottom, top, near, far) {
  return new Float32Array([
    2/(right-left), 0, 0, 0,
    0, 2/(top-bottom), 0, 0,
    0, 0, -2/(far-near), 0,
    -(right+left)/(right-left),
    -(top+bottom)/(top-bottom),
    -(far+near)/(far-near),
    1
  ]);
}
  
// -------------------- SHADERS --------------------
const vsSource = `
attribute vec2 a_Pos;
attribute vec2 a_Tex;
uniform mat4 u_proj;
varying vec2 v_Tex;

void main() {
    gl_Position = u_proj * vec4(a_Pos, 0.0, 1.0);
    v_Tex = a_Tex;
}
`;

const fsSource = `
precision mediump float;
varying vec2 v_Tex;
uniform sampler2D u_Tex;
void main() {
    gl_FragColor = texture2D(u_Tex, v_Tex);
}
`;

// Modified: vsMask now accepts a normalized quad (0..1) and a uMaskBounds vec4
const vsMaskSource = `
attribute vec2 a_Pos;
uniform mat4 u_proj;
uniform vec4 uMaskBounds; // x=left, y=right, z=bottom, w=top
varying vec2 v_worldPos;
void main() {
    // Map normalized [0..1] a_Pos into world-space using uMaskBounds
    float worldX = uMaskBounds.x + a_Pos.x * (uMaskBounds.y - uMaskBounds.x);
    float worldY = uMaskBounds.z + a_Pos.y * (uMaskBounds.w - uMaskBounds.z);
    v_worldPos = vec2(worldX, worldY);
    gl_Position = u_proj * vec4(v_worldPos, 0.0, 1.0);
}
`;

// This fragment shader is used previously for drawing the visible white/black ring in overlay.
// We'll keep it for the overlay (so handles and visual ring look the same).
const fsMaskSource = `
precision mediump float;

uniform vec2 uCenter;     // world pos
uniform float uRx;        // ellipse radius X (world)
uniform float uRy;        // ellipse radius Y (world)
uniform float uRotation;  // radians
uniform float uThicknessPx; // world thickness
uniform float uFeatherPx;   // softness

uniform float uOutlinePx; // 1px black outline width in SCREEN pixels
uniform float uPixelSize; // world units per screen pixel (1/zoom)

varying vec2 v_worldPos;

float ellipseDist(vec2 p, vec2 center, float rx, float ry, float rotation) {
    // translate
    vec2 d = p - center;

    // rotate by -rotation
    float c = cos(rotation);
    float s = sin(rotation);
    vec2 r = vec2(
        d.x * c + d.y * s,
       -d.x * s + d.y * c
    );

    // normalized ellipse distance
    return length(vec2(r.x / rx, r.y / ry));
}

void main() {
    float d = ellipseDist(v_worldPos, uCenter, uRx, uRy, uRotation);
    
    // Convert world thickness to normalized ellipse distance:
    float normThickness = uThicknessPx / min(uRx, uRy);
    float normFeather   = uFeatherPx   / min(uRx, uRy);

    // ---- Main white ring ----
    float inner = 1.0 - normThickness;
    float outer = 1.0 + normThickness;
    
    float whiteRing =
        smoothstep(inner - normFeather, inner + normFeather, d) *
        (1.0 - smoothstep(outer - normFeather, outer + normFeather, d));
    
    // ---- Outer 1px black outline ----
    float outlineInner = outer;
    float outlineOuter = outer + (uOutlinePx * uPixelSize) / min(uRx, uRy);

    float blackRing =
        smoothstep(outlineInner - normFeather, outlineInner + normFeather, d) *
        (1.0 - smoothstep(outlineOuter - normFeather, outlineOuter + normFeather, d));

    // Composite: black ring behind white ring
    float finalAlpha = max(whiteRing, blackRing);

    if (finalAlpha < 0.01) discard;

    vec3 color =
        (blackRing > whiteRing) ?
        vec3(0.0) :          // black outer border
        vec3(1.0);           // white inner ring

    gl_FragColor = vec4(color, finalAlpha);
}
`;

// -------------------- NEW: Mask generation shader (writes feathered mask to texture) --------------------
// This shader writes the per-pixel mask value into the red channel (0..1).
const fsMaskGenSource = `
precision highp float;

uniform vec2 uCenter;     // world pos
uniform float uRx;        // ellipse radius X (world)
uniform float uRy;        // ellipse radius Y (world)
uniform float uRotation;  // radians
uniform float uFeatherPx; // feather in SCREEN pixels
uniform float uPixelSize; // world units per screen pixel (1/zoom)

varying vec2 v_worldPos;

float ellipseDist(vec2 p, vec2 center, float rx, float ry, float rotation) {
    vec2 d = p - center;
    float c = cos(rotation);
    float s = sin(rotation);
    vec2 r = vec2(
        d.x * c + d.y * s,
       -d.x * s + d.y * c
    );
    return length(vec2(r.x / rx, r.y / ry));
}

void main() {
    float d = ellipseDist(v_worldPos, uCenter, uRx, uRy, uRotation);

    // convert feather in screen pixels to normalized ellipse distance
    // feather world units = uFeatherPx * uPixelSize
    float normFeather = (uFeatherPx * uPixelSize) / min(uRx, uRy);

    float inner = 1.0 - normFeather;

    float mask;
    if (d < inner) {
        mask = 1.0;
    } else if (d > 1.0) {
        mask = 0.0;
    } else {
        mask = smoothstep(1.0, inner, d);
    }

    gl_FragColor = vec4(mask, 0.0, 0.0, 1.0);
}
`;

// -------------------- NEW: Composite shader --------------------
// Samples the original image and the mask texture and applies exposure in masked areas.
const fsCompositeSource = `
precision highp float;
varying vec2 v_worldPos;

uniform sampler2D uImage;
uniform sampler2D uMask;
uniform float uExposure; // in stops
uniform float uImgW;
uniform float uImgH;

void main() {
    // compute uv from world pos (image-space -> uv)
    vec2 uv = vec2(v_worldPos.x / uImgW, 1.0 - (v_worldPos.y / uImgH));
    // clamp uv to avoid sampling outside
    uv = clamp(uv, vec2(0.0), vec2(1.0));

    vec3 base = texture2D(uImage, uv).rgb;
    float mask = texture2D(uMask, uv).r;

    float expFactor = pow(2.0, uExposure);
    vec3 adjusted = base * expFactor;

    vec3 finalColor = mix(base, adjusted, mask);

    gl_FragColor = vec4(finalColor, 1.0);
}
`;

// Vertex shader for mask-gen & composite & overlay is the same as vsMaskSource (maps unit quad -> world via uMaskBounds)

// -------------------- INIT WEBGL --------------------
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");
if (!gl) alert("WebGL not supported");

function compileShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        alert(gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
}

const vs = compileShader(gl.VERTEX_SHADER, vsSource);
const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);

const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);
  
const vsMask = compileShader(gl.VERTEX_SHADER, vsMaskSource);
const fsMask = compileShader(gl.FRAGMENT_SHADER, fsMaskSource);

const maskProgram = gl.createProgram();
gl.attachShader(maskProgram, vsMask);
gl.attachShader(maskProgram, fsMask);
gl.linkProgram(maskProgram);

// -------------------- NEW PROGRAMS --------------------
const vsMaskGen = vsMask; // reuse compiled vertex shader (same source)
const fsMaskGen = compileShader(gl.FRAGMENT_SHADER, fsMaskGenSource);
const maskGenProgram = gl.createProgram();
gl.attachShader(maskGenProgram, vsMaskGen);
gl.attachShader(maskGenProgram, fsMaskGen);
gl.linkProgram(maskGenProgram);

const vsComposite = vsMask; // reuse same vertex shader
const fsComposite = compileShader(gl.FRAGMENT_SHADER, fsCompositeSource);
const compositeProgram = gl.createProgram();
gl.attachShader(compositeProgram, vsComposite);
gl.attachShader(compositeProgram, fsComposite);
gl.linkProgram(compositeProgram);

// get attrib/uniform locations (existing)
const aPos = gl.getAttribLocation(program, "a_Pos");
const aTex = gl.getAttribLocation(program, "a_Tex");
const uTex = gl.getUniformLocation(program, "u_Tex");
const uProj = gl.getUniformLocation(program, "u_proj");

// mask program locations
const aMaskPos = gl.getAttribLocation(maskProgram, "a_Pos");
const uMaskProj = gl.getUniformLocation(maskProgram, "u_proj");
const uMaskBounds = gl.getUniformLocation(maskProgram, "uMaskBounds"); // NEW
const uMaskCenter = gl.getUniformLocation(maskProgram, "uCenter");
const uMaskThicknessPx = gl.getUniformLocation(maskProgram, "uThicknessPx");  
const uMaskFeatherPx = gl.getUniformLocation(maskProgram, "uFeatherPx");
const uMaskOutlinePx = gl.getUniformLocation(maskProgram, "uOutlinePx");
const uMaskPixelSize = gl.getUniformLocation(maskProgram, "uPixelSize");
const uMaskRx = gl.getUniformLocation(maskProgram, "uRx");
const uMaskRy = gl.getUniformLocation(maskProgram, "uRy");
const uMaskRotation = gl.getUniformLocation(maskProgram, "uRotation");

// maskGen uniforms
const aMaskGenPos = gl.getAttribLocation(maskGenProgram, "a_Pos");
const uMaskGenProj = gl.getUniformLocation(maskGenProgram, "u_proj");
const uMaskGenBounds = gl.getUniformLocation(maskGenProgram, "uMaskBounds");
const uMaskGenCenter = gl.getUniformLocation(maskGenProgram, "uCenter");
const uMaskGenRx = gl.getUniformLocation(maskGenProgram, "uRx");
const uMaskGenRy = gl.getUniformLocation(maskGenProgram, "uRy");
const uMaskGenRotation = gl.getUniformLocation(maskGenProgram, "uRotation");
const uMaskGenFeatherPx = gl.getUniformLocation(maskGenProgram, "uFeatherPx");
const uMaskGenPixelSize = gl.getUniformLocation(maskGenProgram, "uPixelSize");

// composite uniforms
const aCompositePos = gl.getAttribLocation(compositeProgram, "a_Pos");
const uCompositeProj = gl.getUniformLocation(compositeProgram, "u_proj");
const uCompositeBounds = gl.getUniformLocation(compositeProgram, "uMaskBounds");
const uCompositeImage = gl.getUniformLocation(compositeProgram, "uImage");
const uCompositeMask = gl.getUniformLocation(compositeProgram, "uMask");
const uCompositeExposure = gl.getUniformLocation(compositeProgram, "uExposure");
const uCompositeImgW = gl.getUniformLocation(compositeProgram, "uImgW");
const uCompositeImgH = gl.getUniformLocation(compositeProgram, "uImgH");

// -------------------- MASK FBO + TEXTURE (NEW) --------------------
let maskFbo = null;
let maskTexture = null;

// We'll also keep a reference to the image texture
let imageTexture = null;

function createMaskFbo() {
    // delete previous if exists
    if (maskTexture) { gl.deleteTexture(maskTexture); maskTexture = null; }
    if (maskFbo) { gl.deleteFramebuffer(maskFbo); maskFbo = null; }

    maskTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, maskTexture);
    // RGBA8 because webgl1 doesn't expose R8; sample red channel anyway
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    maskFbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, maskFbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, maskTexture, 0);

    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
        console.warn("Mask FBO incomplete:", status);
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

// -------------------- CREATE BUFFERS --------------------
function createScreenBuffer(){
  //gl.viewport(0, 0, canvas.width, canvas.height);
  
  // Unit quad (normalized 0..1). We'll map this to the current world view using uMaskBounds.
  const screenVertices = new Float32Array([
    // X, Y  (normalized)
    0.0, 0.0,  // bottom-left
    1.0, 0.0,  // bottom-right
    1.0, 1.0,  // top-right
    0.0, 1.0   // top-left
  ]);
  
  const screenIndices = new Uint16Array([
    0, 1, 2,
    0, 2, 3
  ]);
  
  // ---- VBO ----
  const screenBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, screenBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, screenVertices, gl.STATIC_DRAW);
  
  // ---- EBO (Index Buffer) ----
  const screenIBO = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenIBO);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, screenIndices, gl.STATIC_DRAW);

  // IMPORTANT: set attribute pointer for every program that will use this quad.
  // Previously we only set aMaskPos (for maskProgram). Now set for maskProgram, maskGenProgram, compositeProgram.

  // maskProgram attribute
  if (aMaskPos !== -1 && aMaskPos !== null) {
    gl.enableVertexAttribArray(aMaskPos);
    gl.vertexAttribPointer(aMaskPos, 2, gl.FLOAT, false, 0, 0);
  }

  // maskGenProgram attribute (may have different location index)
  if (aMaskGenPos !== -1 && aMaskGenPos !== null) {
    gl.enableVertexAttribArray(aMaskGenPos);
    gl.vertexAttribPointer(aMaskGenPos, 2, gl.FLOAT, false, 0, 0);
  }

  // compositeProgram attribute
  if (aCompositePos !== -1 && aCompositePos !== null) {
    gl.enableVertexAttribArray(aCompositePos);
    gl.vertexAttribPointer(aCompositePos, 2, gl.FLOAT, false, 0, 0);
  }
}

function createImageBuffer(){
  // -------------------- RECTANGLE GEOMETRY --------------------
  // Full-screen rectangle (-1 to +1)
  const vertices = new Float32Array([
    //  X,   Y,   U,  V
    0,        imgHeight,  0,  0,  // bottom-left
    imgWidth, imgHeight,  1,  0,  // bottom-right
    imgWidth, 0,          1,  1,  // top-right
    0,        0,          0,  1   // top-left
  ]);
  
  const indices = new Uint16Array([
    3, 2, 0,
    0, 1, 2
  ]);
  
  // ---- VBO ----
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

  // ---- EBO (Index Buffer) ----
  const ibo = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 16, 0);

  gl.enableVertexAttribArray(aTex);
  gl.vertexAttribPointer(aTex, 2, gl.FLOAT, false, 16, 8);

  gl.uniform1i(uTex, 0); // bind texture unit 0
}

function loadImageToTexture(image){
    const tex = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,image);

    const err = gl.getError();
    console.log("GL ERROR after texImage2D:", err);
  
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    // NEW: store global reference to image texture
    imageTexture = tex;
}
// -------------------- LOAD IMAGE --------------------
const image = new Image();
image.src = "img1.jpg";  // ← your image
image.onload = () => {
    console.log("IMAGE LOADED");
    imgHeight = image.height;
    imgWidth = image.width;
    
    createScreenBuffer();
    createImageBuffer();
    loadImageToTexture(image);

    // create mask FBO now that canvas size and image are known
    createMaskFbo();
};

function resetViewToFit() {
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
  
  const screenW = canvas.clientWidth;
  const screenH = canvas.clientHeight;

  // Fit image inside screen
  zoom = Math.min(screenW / imgWidth, screenH / imgHeight);

  // Compute how large the ortho window will become
  const viewW = screenW / zoom;
  const viewH = screenH / zoom;

  // Center camera so image is perfectly centered
  camX = (imgWidth  - viewW) / 2;
  camY = (imgHeight - viewH) / 2;

  // recreate mask FBO for new canvas size
  if (canvas.width > 0 && canvas.height > 0) createMaskFbo();
}

function renderMaskSelection(mask){
  gl.useProgram(maskProgram);
  
  gl.uniform2f(uMaskCenter, mask.center.x, mask.center.y);
  gl.uniform1f(uMaskRx, mask.rx);
  gl.uniform1f(uMaskRy, mask.ry);
  gl.uniform1f(uMaskRotation, mask.rotation);
  gl.uniform1f(uMaskThicknessPx, 1.0/zoom);
  gl.uniform1f(uMaskFeatherPx, 0.2); // Try 1→3 for smoother edges
  // black outline stays exactly 1px on screen
  gl.uniform1f(uMaskOutlinePx, 1.0);
  // world units per pixel
  gl.uniform1f(uMaskPixelSize, 1.0 / zoom);
  
  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
}
  
function renderHandleCircle(x, y) {
    gl.useProgram(maskProgram);
    gl.uniform2f(uMaskCenter, x, y);

    const rad = (HANDLE_PX * 0.5) / zoom;
    const thick = (HANDLE_PX * 0.6) / zoom;

    gl.uniform1f(uMaskRx, rad);
    gl.uniform1f(uMaskRy, rad);
    gl.uniform1f(uMaskThicknessPx, thick);
    gl.uniform1f(uMaskFeatherPx, 0.7 / zoom);
    gl.uniform1f(uMaskOutlinePx, 1.0);
    gl.uniform1f(uMaskPixelSize, 1.0 / zoom);

    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
}

function renderMaskCenterHandles() {
  let w = canvas.width / zoom;
  let h = canvas.height / zoom;

  let left = camX;
  let right = camX + w;
  let bottom = camY;
  let top = camY + h;
  
  gl.useProgram(maskProgram);
  const maskProj = ortho(left, right, bottom, top, -1, 1);
  gl.uniformMatrix4fv(uMaskProj, false, maskProj);

  // NEW: provide bounds so the unit quad maps to the current world view
  gl.uniform4f(uMaskBounds, left, right, bottom, top);
  
  masks.forEach(mask => {
    // A small circle (white)
    gl.uniform2f(uMaskCenter, mask.center.x, mask.center.y);

    // Screen-pixel-constant radius
    const handleRadiusPx = 12; // 12px diameter
    const rad = HANDLE_PX / zoom;
    const thick = (HANDLE_PX * 0.6) / zoom;
  
    gl.uniform1f(uMaskRx, rad);
    gl.uniform1f(uMaskRy, rad);
    gl.uniform1f(uMaskThicknessPx, thick);
    gl.uniform1f(uMaskFeatherPx, 0.7);
    gl.uniform1f(uMaskOutlinePx, 1.0);
    gl.uniform1f(uMaskPixelSize, 1.0 / zoom);

    // Draw on the full-view quad (mapped using uMaskBounds)
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

    if (mask.selected && mask.outline){
      renderMaskSelection(mask);

      const handle = getEllipseHandlePositions(mask);
      // resize handles
      renderHandleCircle(handle.right.x, handle.right.y);
      renderHandleCircle(handle.left.x, handle.left.y);
      renderHandleCircle(handle.top.x, handle.top.y);
      renderHandleCircle(handle.bottom.x, handle.bottom.y);

      // rotate handle
      renderHandleCircle(handle.rotate.x, handle.rotate.y);
  }
  });
}

// -------------------- NEW: Render mask(s) into maskTexture FBO --------------------
function renderMasksToTexture() {
    if (!maskFbo || !maskTexture) return;

    // Bind mask FBO and render into it
    gl.bindFramebuffer(gl.FRAMEBUFFER, maskFbo);
    gl.viewport(0, 0, canvas.width, canvas.height);

    // Clear mask texture to zero
    gl.clearColor(0,0,0,0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Set projection/bounds so our unit quad maps to world
    let w = canvas.width / zoom;
    let h = canvas.height / zoom;
    let left = camX;
    let right = camX + w;
    let bottom = camY;
    let top = camY + h;
    const maskProj = ortho(left, right, bottom, top, -1, 1);

    // We will draw masks that are selected OR have non-zero exposure
    gl.useProgram(maskGenProgram);
    gl.uniformMatrix4fv(uMaskGenProj, false, maskProj);
    gl.uniform4f(uMaskGenBounds, left, right, bottom, top);

    // Use additive blending so overlapping selected masks combine (clamped to 1.0)
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE);

    // draw each relevant mask into mask texture
    for (let mask of masks) {
        if (!mask.selected && Math.abs(mask.exposure) < 1e-6) continue; // only selected or non-zero exposure

        gl.uniform2f(uMaskGenCenter, mask.center.x, mask.center.y);
        gl.uniform1f(uMaskGenRx, mask.rx);
        gl.uniform1f(uMaskGenRy, mask.ry);
        gl.uniform1f(uMaskGenRotation, mask.rotation);
        // feather passed in screen pixels
        gl.uniform1f(uMaskGenFeatherPx, mask.feather);
        gl.uniform1f(uMaskGenPixelSize, 1.0 / zoom);

        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    }

    // restore default blending
    gl.disable(gl.BLEND);

    // unbind FBO — next we'll composite to the default framebuffer
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

// -------------------- NEW: Composite pass (image + mask -> screen) --------------------
function renderComposite() {
    // Bind default framebuffer (already the default when null)
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, canvas.width, canvas.height);

    // Setup projection/bounds
    let w = canvas.width / zoom;
    let h = canvas.height / zoom;
    let left = camX;
    let right = camX + w;
    let bottom = camY;
    let top = camY + h;
    const compProj = ortho(left, right, bottom, top, -1, 1);

    gl.useProgram(compositeProgram);
    gl.uniformMatrix4fv(uCompositeProj, false, compProj);
    gl.uniform4f(uCompositeBounds, left, right, bottom, top);

    // bind image texture -> unit 0
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, imageTexture);
    gl.uniform1i(uCompositeImage, 0);

    // bind mask texture -> unit 1
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, maskTexture);
    gl.uniform1i(uCompositeMask, 1);

    // exposure: use maskCurrent.exposure if set, else 0
    let exposure = 0.0;
    if (maskCurrent && maskCurrent.selected) exposure = maskCurrent.exposure;
    gl.uniform1f(uCompositeExposure, exposure);

    // image dims for uv mapping
    gl.uniform1f(uCompositeImgW, imgWidth);
    gl.uniform1f(uCompositeImgH, imgHeight);

    // draw the quad (samples image + mask inside shader)
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

    // unbind textures
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, null);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, null);
}

// -------------------- DRAW (updated pipeline) --------------------
function draw() {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
    
    let w = canvas.width / zoom;
    let h = canvas.height / zoom;

    let left = camX;
    let right = camX + w;
    let bottom = camY;
    let top = camY + h;
    
    // ---------- We no longer draw the image directly to screen ----------
    // Instead:
    // 1) render selected/active masks into maskTexture
    // 2) composite image + maskTexture to screen
    // 3) draw overlay handles on top

    // 1) render mask(s) to texture
    renderMasksToTexture();

    // 2) composite pass (image + mask -> screen)
    renderComposite();

    // 3) overlay handles (drawn on top of the composed image)
    renderMaskCenterHandles();
}

// ---------------------------------------------------------
// Touch Events (Pan + Pinch Zoom)
// ---------------------------------------------------------
canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  
  const t = e.touches[0];
  const hit = hitResizeOrRotate(t.clientX, t.clientY);
  if (hit) {
      maskCurrent = hit.mask;
      activeHandle = hit.type;
      centerTouchId = t.identifier;
      lastX = t.clientX;
      lastY = t.clientY;
      
      if (hit.type === "rotate") {
        const worldStart = screenToWorld(t.clientX, t.clientY);
        // save initial angle between center and touch
        rotateStartAngle = Math.atan2(worldStart.y - maskCurrent.center.y, worldStart.x - maskCurrent.center.x);
        // save current ellipse rotation
        rotateStartRot = maskCurrent.rotation;
      }
      return;
  }

  if (e.touches.length === 1) {
    // Single-finger pan
    isTouching = true;
    isPinching = false;
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  } else if (e.touches.length === 2) {
    // Start pinch
    isPinching = true;
    lastDist = distance(e.touches[0], e.touches[1]);
    lastMid = midpoint(e.touches[0], e.touches[1]);
  }
});

function worldDeltaToLocal(dx, dy) {
    const c = Math.cos(-maskCurrent.rotation);
    const s = Math.sin(-maskCurrent.rotation);
    return {
        x: dx * c - dy * s,
        y: dx * s + dy * c
    };
}
  
canvas.addEventListener("touchmove", e => {
  e.preventDefault();

  if (activeHandle) {
    const t = [...e.touches].find(x => x.identifier === centerTouchId);
    if (!t) return;

    const before = screenToWorld(lastX, lastY);
    const now    = screenToWorld(t.clientX, t.clientY);

    const dx = now.x - before.x;
    const dy = now.y - before.y;

    let loc = null;
    switch(activeHandle) {

        case "center":
            isCenterDragging = true;
            maskCurrent.center.x += dx;
            maskCurrent.center.y += dy;
            break;

        case "resize-right":
           loc = worldDeltaToLocal(dx, dy);
           maskCurrent.rx += loc.x;     // only x-direction in local space affects rx
           if (maskCurrent.rx < 5) maskCurrent.rx = 5;
           break;

        case "resize-left":
           loc = worldDeltaToLocal(dx, dy);
           maskCurrent.rx -= loc.x;     // inverted
           if (maskCurrent.rx < 5) maskCurrent.rx = 5;
           break;

        case "resize-top":
           loc = worldDeltaToLocal(dx, dy);
           maskCurrent.ry += loc.y;
           if (maskCurrent.ry < 5) maskCurrent.ry = 5;
           break;

        case "resize-bottom":
           loc = worldDeltaToLocal(dx, dy);
           maskCurrent.ry -= loc.y;
           if (maskCurrent.ry < 5) maskCurrent.ry = 5;
           break;

        case "rotate":
          const worldNow = screenToWorld(t.clientX, t.clientY);
          const nowAngle = Math.atan2(worldNow.y - maskCurrent.center.y, worldNow.x - maskCurrent.center.x);
          // delta between angles
          const delta = nowAngle - rotateStartAngle;
          // update rotation
          maskCurrent.rotation = rotateStartRot + delta;
          break;
    }

    lastX = t.clientX;
    lastY = t.clientY;
    draw();
    return;
  }

  // --- Pinch Zoom ---
  if (isPinching && e.touches.length === 2) {
    const t1 = e.touches[0];
    const t2 = e.touches[1];

    // Midpoint in client coords
    const mid = midpoint(t1, t2);

    // Convert midpoint to world coords BEFORE zooming
    const worldBefore = screenToWorld(mid.x, mid.y);

    // Zoom amount
    let newDist = distance(t1, t2);
    let scale = newDist / lastDist;

    // Apply zoom with limits
    let newZoom = zoom * scale;
    newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));

    // Adjust pan so world point under fingers stays stable
    zoom = newZoom;

    // Convert midpoint to world coords AFTER zooming
    const worldAfter = screenToWorld(mid.x, mid.y);

    // Offset camera to keep focus stable
    camX += (worldBefore.x - worldAfter.x);
    camY += (worldBefore.y - worldAfter.y);

    lastDist = newDist;
    lastMid = mid;

    draw();
    return;
  }
  
  // ----- Single finger pan -----
  if (isTouching && e.touches.length === 1) {
    const t = e.touches[0];

    let dx = t.clientX - lastX;
    let dy = t.clientY - lastY;

    camX -= dx * (1 / zoom);
    camY += dy * (1 / zoom);

    lastX = t.clientX;
    lastY = t.clientY;

    draw();
  }
});
  
canvas.addEventListener("touchend", e => {
  if (activeHandle == "center" && !isCenterDragging){
    maskCurrent.outline = !maskCurrent.outline;
    selectMask(maskCurrent.id);
  }
  
  if (activeHandle == null){
    maskCurrent.outline = false;
  }
  
  isCenterDragging = false;
  isResizing = false;
  isRotating = false;
  centerTouchId = null;
  activeHandle = null;

  if (e.touches.length < 2) {
    isTouching = false;
    isPinching = false;
  }
  draw();
});
  
// ---------------------------------------------------------
// Mouse support (optional)
// ---------------------------------------------------------
let mouseDown = false;
  
canvas.addEventListener("mousedown", e => {
  mouseDown = true;
  lastX = e.clientX;
  lastY = e.clientY;
});
canvas.addEventListener("mouseup", () => mouseDown = false);
canvas.addEventListener("mousemove", e => {
  if (!mouseDown) return;
  let dx = e.clientX - lastX;
  let dy = e.clientY - lastY;

  camX -= dx * (1 / zoom);
  camY += dy * (1 / zoom);

  lastX = e.clientX;
  lastY = e.clientY;

  draw();
});
canvas.addEventListener("wheel", e => {
  const z = 1.1;
  zoom *= (e.deltaY < 0 ? z : 1/z);
  zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));
  draw();
});

  
function init() {
    resetViewToFit();
    draw();           // ✓ draw first frame
}
  
window.onload = init;
</script>
</body>
</html>